#!/usr/bin/env python

"""A Python command-line wrapper with github3.py library to access GitHub Gist.
"""

from github3 import authorize
from getpass import getuser, getpass
from github3 import login
from github3.models import GitHubError

import argparse
from functools import wraps
import os
import requests
import sys

def auth_check(func):
    """Decorator to note which object methods require authorization"""
    @wraps(func)
    def check_wrapper(self, *args, **kwargs):
        """A wrapper to check if a token exists"""
        if not kwargs.get('anonymous'):
            try:
                with open(os.path.expanduser('~/.pgist'), 'r') as tkf:
                    self.token = tkf.readline()
                self.github = login(token=self.token)
            except IOError:
                raise SystemExit('Read token file failed, please use '\
                        '`pgist --login` to request token')
        try:
            return func(self, *args, **kwargs)
        except GitHubError, ghe:
            if ghe.code in (401, 403):
                raise SystemExit('Your current token is bad, please request it'\
                        ' with `pgist --login` again!')
            raise SystemExit(ghe + '\nPlease report this bug to the author!')
    return check_wrapper

def token_request():
    """Request app token from GitHub to operate gists"""
    user = raw_input('GitHub username(default is {0}): '.format(getuser())) \
            or getuser()
    password = ''

    while not password:
        password = getpass('GitHub password for {0}: '.format(user))

    note = 'pgist'
    note_url = 'https://github.com/douglarek/pgist'
    scopes = ['user', 'gist']

    try:
        auth = authorize(user, password, scopes, note, note_url)
    except GitHubError:
        raise SystemExit('Request app token failed, please check your username'\
                'or password!')

    with open(os.path.expanduser('~/.pgist'), 'w') as tkf:
        tkf.write(auth.token)

    print 'Done ...'

def url_shorten(long_url):
    """Shorten a long url with git.io service"""
    req = requests.post('http://git.io', data={'url' : long_url})
    return req.headers['location']

class Gist(object):
    """Define known gist operations"""

    def __init__(self):
        self.token, self.github = None, None

    @auth_check
    def list_gists(self, private=False):
        """List all gists or public only ones"""
        print 'List of {0} gists: \n'.format(['public','all'][private])
        if private:
            for gist in self.github.iter_gists():
                print [g.name for g in gist.iter_files()][0].ljust(30), \
                        gist.html_url
        else:
            for gist in self.github.iter_gists():
                if gist.public:
                    print [g.name for g in gist.iter_files()][0].ljust(30), \
                            gist.html_url

    @auth_check
    def create_gist(self,
                    description=None,
                    files=(),
                    public=True,
                    anonymous=False,
                    short_url=False):
        """Create public, private or anonymous gists"""
        if description is None:
            description = ''

        files = [f for f in files if os.path.exists(f)]
        upload_files = {}
        for _ in files:
            with open(_, 'r') as _fd:
                content = _fd.readlines()
                if not content:
                    continue
                upload_files[os.path.basename(_)] = {'content' : \
                        ''.join(content)}

        if not upload_files:
            raise SystemExit('All of your files are empty, WTF?')

        if anonymous:
            from github3 import create_gist
            gist = create_gist(description, upload_files)
        else:
            gist = self.github.create_gist(description, upload_files, \
                    public)

        print url_shorten(gist.html_url) if short_url else gist.html_url

def main(argv):
    """The main body"""
    description = 'A Python command-line wrapper with github3.py library '\
            'to access GitHub gists'
    parser = argparse.ArgumentParser(description=description)

    parser.add_argument('-l', '--list', \
            help='list of all your public gists, '\
            'with `-p` show all contains private ones', \
            action='store_true')

    parser.add_argument('-p', '--private', action='store_true')
    parser.add_argument('-s', '--short', action='store_true')

    parser.add_argument('files', nargs='*', type=os.path.abspath, \
            help='files which will be uploaded, '\
            'separate multiple ones with space, '\
            'with `-d` add description; '\
            '`-p` create a private one; '\
            '`-a` create an anonymous one; '\
            '`-s` show a short url')
    parser.add_argument('-d', '--description')
    parser.add_argument('-a', '--anonymous', \
            action='store_true')

    parser.add_argument('--login', help='request app token', \
            action='store_true')

    args = parser.parse_args(argv)

    gist = Gist()

    if args.list:
        gist.list_gists(private=[False, True][args.private])
    elif args.files:
        gist.create_gist(args.description, args.files, \
                [True, False][args.private], anonymous=args.anonymous, \
                short_url=args.short)
    elif args.login:
        token_request()
    else:
        parser.print_help()

if __name__ == '__main__':
    try:
        sys.exit(main(sys.argv[1:]))
    except KeyboardInterrupt:
        raise SystemExit('\nOk, Goodbye.')
